package pa1;

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.math.BigInteger;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.nio.charset.StandardCharsets;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Author: Matthew Mendez
 * 
 * A MalwareProxy asynchronously makes HTTP requests
 * on behalf of its clients, calculates the MD5 checksum
 * for each response body and tests it against the Team
 * Cymru Malware Hash Registry. If the object is suspected
 * of malware, a simple html page is returned to the client
 * notifying them of the suspicion. Returns the requested
 * object otherwise.
 * 
 * One HTTP request per connection. 
 * Once a request is processed, the connection
 * is closed.
 */
public class MalwareProxy 
{
	/**
	 * MalwareProxy Constructor listens for TCP connections
	 * and asynchronously processes each connection.
	 */
	public MalwareProxy(int serverPort)
	{
		ServerSocket serverSocket; // Listens for TCP connection requests from clients 
		Socket connectionSocket; // Communicates with client once a connection is made.
		try 
		{
			serverSocket = new ServerSocket(serverPort);
		} 
		catch (IOException e) 
		{ 
			e.printStackTrace();
			return; // End the program if there are issues opening the socket on the specified port
		}
		
		while(true)
		{
			try 
			{
				// Wait for a connection to be made (blocks)
				connectionSocket = serverSocket.accept();
				
				// Create a new thread for each connection.
				new Thread(getClientProcessRunnable(connectionSocket)).start();
			} 
			catch (IOException e) 
			{
				e.printStackTrace(); // Print error and continue listening for connectionr requests.
			}
		}
	}
	
	/**
	 * Returns a Runnable that processes the parameterized connection socket.
	 * Socket processing includes reading the request, verifying HTTP request
	 * format, altering request for server to interpret, making the request
	 * on behalf of the socket, checking the returned object for malware, and
	 * either returning the object or a "suspected malware" message back to
	 * the client.
	 */
	private Runnable getClientProcessRunnable(Socket connectionSocket)
	{
		return new Runnable()
		{
			@Override
			public void run() 
			{
				try
				{
					// Output Stream is necessary because it interprets data as binary
					// data (as opposed to interpreting as strings). This way, different
					// encoding formats can be passed back to the client.
					OutputStream connectionOutputStream = connectionSocket.getOutputStream();	
					
					// Read the client request as a string.
					String userRequest = readRequest(connectionSocket);
					if(userRequest == null || userRequest.trim().equals(""))
					{
						connectionSocket.close(); // Also closes associated streams.
						return;
					}
					
					// Returns null if request was properly formatted.
					String errorMessage = validateRequest(userRequest);
					if(errorMessage != null)
					{
						connectionOutputStream.write((errorMessage + "\n").getBytes());
						connectionSocket.close(); // Also closes associated streams.
						return;
					}
					
					// Parse the request and put it into relative URI HTTP format.
					userRequest = modifyRequstForWebServer(userRequest);
					
					// Make the request and return the response to the client.
					// It is possible that an error message is returned from 
					// requestToWebServer before a server request is made.
					ArrayList<Byte> response = requestToWebServer(userRequest);
					
					// Strip out the HTTP headers from the response and run the
					// MD5 hash algorithm on the body. 
					String hash = calculateMd5OfResponseBody(response);
					
					// Make the request with the hash value to the Cymru registry.
					String cymruResponse = makeMD5RequestToCymru(hash);
					
					// If the response from Team Cymru contains "NO_DATA", the hash 
					// is not associated with malware.
					if(cymruResponse.contains("NO_DATA"))
						for(byte b : response)
							connectionOutputStream.write(b);
					
					else // The response body is associated with malware.
					{
						String malwareResponse = "HTTP/1.1 200 OK\r\nConnection:close\r\nContent-Type: text/html\r\n\r\n" +
												 "<html><head><title>Malware Detected</title></head><body><p>The object you" +
												 "requested is suspected of malware.</p></body></html>\r\n";
						
						DataOutputStream dos = new DataOutputStream(connectionOutputStream);
						dos.writeBytes(malwareResponse);
					}
					
					connectionSocket.close(); // Also closes associated streams.
				}
				catch(IOException e)
				{
					e.printStackTrace();
				}
			}
		};
	}
	
	/**
	 * Reads a request from an open socket and returns it. The
	 * request is considered final when an empty line is sent
	 * from the client.
	 */
	private String readRequest(Socket readSocket)
	{
		String request = "";
		try 
		{
			// BufferedReader allows requests to be interpreted as strings.
			BufferedReader socketBufferedReader
				= new BufferedReader(new InputStreamReader(readSocket.getInputStream()));
			
			String line;
			while((line = socketBufferedReader.readLine()) != null)
			{
				// When there is an empty line, it is the end of the request
				if(line.equals(""))
					break;
				request += line + "\n";
			}
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
			return null;
		}
		
		return request;
	}
	
	/**
	 * Validates the format of an HTTP GET request.
	 * Returns an error message if validation fails.
	 * Returns null if the request is properly formatted.
	 */
	private String validateRequest(String request) 
	{
		int line = 0;
		Scanner scanner = new Scanner(request);
		while(scanner.hasNextLine())
		{
			String message = scanner.nextLine();
			
			// Request Line
			if(line == 0)
			{
				// Message must be in absolute or relative uri form.
				if(!message.matches("GET http://.+\\..+(\\..+)*/(|.*) HTTP/1.0") && !message.matches("GET /(|.*) HTTP/1.0"))
				{
					if(!message.startsWith("GET"))
						return "501 Not Implemented";
					else
						return "400 Bad Request Line Format";
				}
			}
			// Headers
			else if(!message.matches(".*: .*"))
				return "400 Bad Header Format";
			
			line++;
		}
		return null;
	}
	
	/**
	 * Takes a properly formatted relative or absolute HTTP request 
	 * and changes it into (relative HTTP request line) + (Host: ...)
	 * request form to be sent to a web server.
	 */
	private String modifyRequstForWebServer(String userRequest) 
	{
		String result = "";
		
		// First make sure the connection header is "Connection: close"
		if(userRequest.contains("Connection: "))
			userRequest = userRequest.replaceFirst("Connection: .*\n", "Connection: close\n");
		else
			userRequest += "Connection: close\n";
			
		String pathname = "";
		
		// Absolute Request
		if(userRequest.startsWith("GET http"))
		{
			String host = userRequest.substring(11, userRequest.indexOf("/", 11));
			pathname = userRequest.substring(userRequest.indexOf("/", 11), userRequest.indexOf(" ", 11));
			
			// Make sure the Host header line matches the host in the request line.
			if(userRequest.contains("Host: "))
			{
				userRequest = userRequest.replaceFirst("Host: .*\n", "Host: " + host + "\n");
				result = "GET " + pathname + " HTTP/1.0\n" + userRequest.substring(userRequest.indexOf("\n") + 1) + "\n";	
			}
			else
				// Add in a proper Host header line. 
				result = "GET " + pathname + " HTTP/1.0\nHost: " + host + "\n" + userRequest.substring(userRequest.indexOf("\n") + 1) + "\n";	
		}
		// Relative Request
		else if(userRequest.startsWith("GET /"))
		{
			// Make sure a there is a Host header line.
			if(!userRequest.contains("Host: "))
				return "400 No host specified\n";
			
			pathname = userRequest.substring(userRequest.indexOf("/"), userRequest.indexOf(" ", 4));
			result = "GET " + pathname + " HTTP/1.0\n" +
					userRequest.substring(userRequest.indexOf("\n") + 1) + "\n";
		}
		return result;
	}
	
	/**
	 * Makes a request to the host web server specified in the HTTP request.
	 */
	private ArrayList<Byte> requestToWebServer(String httpRequest)
	{
		try 
		{	
			// Extract the host. 
			String host = httpRequest.substring(httpRequest.indexOf("Host: ") + 6, httpRequest.indexOf("\n", httpRequest.indexOf("Host: ")));
			
			int port = 80;
			
			// Change the port if specified in the request.
			if(host.contains(":"))
			{
				port = Integer.parseInt(host.substring(host.indexOf(":") + 1));
				host = host.substring(0, host.indexOf(":"));
			}
			
			// Open a connection with the host web server.
			Socket clientSocket = new Socket(host, port);
			
			// Make the request
			DataOutputStream hostDataOutputStream = new DataOutputStream(clientSocket.getOutputStream());
			hostDataOutputStream.writeBytes(httpRequest);
			
			ArrayList<Byte> responseByteList = new ArrayList<Byte>();
			InputStream isr = clientSocket.getInputStream();
			
			int c;
			while((c = isr.read()) != -1)
				responseByteList.add((byte)c);
				
			clientSocket.close(); // Also closes associated input/output streams.
			return responseByteList;
			
		} 
		catch (UnknownHostException e) 
		{
			ArrayList<Byte> error = new ArrayList<Byte>();
			for(Byte b : ("400 Unresolvable Host\n").getBytes()) error.add(b);
			return error;
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}	
		
		ArrayList<Byte> error = new ArrayList<Byte>();
		for(Byte b : ("400 There was an error processing your request\n").getBytes()) error.add(b);
		return error;
	}
	
	/**
	 * Takes an md5 hash and makes a request against 
	 * the Team Cymru Malware Registry Database.
	 */
	private String makeMD5RequestToCymru(String request)
	{
		String response = "";
		try 
		{
			// The whois service is provided on port 43. 
			Socket cymruSocket = new Socket("hash.cymru.com", 43);
			DataOutputStream dos = new DataOutputStream(cymruSocket.getOutputStream());
			BufferedReader br = new BufferedReader(new InputStreamReader(cymruSocket.getInputStream()));
			
			// Directly write request with a newline to the whois service and it should yield a response.
			dos.writeBytes(request + "\n");
			
			// Read the response.
			String line;
			while((line = br.readLine()) != null)
				response += line;
			
			cymruSocket.close(); // Closes associated streams
		} 
		catch (UnknownHostException e1) 
		{
			e1.printStackTrace();
		} catch (IOException e1) 
		{
			e1.printStackTrace();
		}
		return response;
	}
	
	/**
	 * Takes an http response, strips the headers and calculates the md5
	 * has for the body of the response.
	 */
	private String calculateMd5OfResponseBody(ArrayList<Byte> response)
	{
		// Find the first occurrence of \r\n\r\n (this is where the body of the http response begins).
		int splitIndex = 0;
		for(; splitIndex < response.size(); splitIndex++)
			if(response.get(splitIndex) == '\r' && response.get(splitIndex+1) == '\n' && response.get(splitIndex+2) == '\r' && response.get(splitIndex+3) == '\n')
				break;
		
		// The split index should be the index immediately after the first occurence of \r\n\r\n
		splitIndex += 4;
		
		byte[] bodyArr;
		// An occurrence of \r\n\r\n was found.
		if(response.size() - splitIndex > 0)
			bodyArr = new byte[response.size() - splitIndex];
		// An occurrence of \r\n\r\n was not found. Simply a 0'd out md5 hash.
		else
			return "00000000000000000000000000000000";
		
		// Add the body bytes to the bodyArr.
		for(int i = splitIndex; i < response.size(); i++)
			bodyArr[i - splitIndex] = response.get(i);
		
		try 
		{
			// The following snippet was inspired by http://www.asjava.com/core-java/java-md5-example/
			MessageDigest hasher = MessageDigest.getInstance("MD5");
			byte[] messageDigest = hasher.digest(bodyArr);
			BigInteger number = new BigInteger(1, messageDigest);
            String hashtext = number.toString(16);
            
            // Pad with zeroes up to 32 character length
            while (hashtext.length() < 32) 
            	hashtext = "0" + hashtext;
	            
	        return hashtext;
		} 
		catch (NoSuchAlgorithmException e) 
		{
			e.printStackTrace();
		}
		return null;
	}
	
	/**
	 * Creates a new MalwareProxy on a port specified
	 * in the first argument of args.
	 */
	public static void main(String[] args) 
	{
		if(args.length != 1)
		{
			System.out.println("Must pass a port number as a program argument.");
			return;
		}
		
		int port = 0;
		try
		{
			port = Integer.parseInt(args[0]);
			new MalwareProxy(port);
		}
		catch(NumberFormatException e){System.out.println("Port number argument could not be parsed as an integer.");}
		catch(Exception e){e.printStackTrace();}
	}
}
